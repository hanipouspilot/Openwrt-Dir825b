#!/bin/sh /etc/rc.common
# Copyright (C) 2010-2014 OpenWrt.org

START=99
USE_PROCD=1
PROG=/usr/sbin/igmpproxy
CONFIGFILE=/var/etc/igmpproxy.conf

# igmpproxy supports both a debug mode and verbosity, which are very useful
# when something isn't working.
#
# Debug mode will print everything to stdout instead of syslog. Generally
# verbosity should NOT be set as it will quickly fill your syslog.
#
# Put any debug or verbosity options into IGMP_OPTS
#
# Examples:
# OPTIONS="-d -v -v" - debug mode and very verbose, this will land in
#                        stdout and not in syslog
# OPTIONS="-v" - be verbose, this will write aditional information to syslog

OPTIONS=""

igmp_header() {
	local quickleave
	config_get_bool quickleave "$1" quickleave 0

	mkdir -p /var/etc
	rm -f /var/etc/igmpproxy.conf
	[ $quickleave -gt 0 ] && echo "quickleave" >> /var/etc/igmpproxy.conf

	[ -L /etc/igmpproxy.conf ] || ln -nsf /var/etc/igmpproxy.conf /etc/igmpproxy.conf
}

igmp_add_phyint() {
	local network direction altnets whitelists device up

	config_get network $1 network
	config_get direction $1 direction
	config_get altnets $1 altnet
	config_get whitelists $1 whitelist

	local status="$(ifstatus $network)"
	[ -n "$status" ] || return

	json_load "$status"
	json_get_var device l3_device
	json_get_var up up

	[ -n "$device" -a "$up" = "1" ] || {
		procd_append_param error "$network is not up"
		return;
	}

	[[ "$direction" = "upstream" ]] && has_upstream=1

	echo -e "\nphyint $device $direction ratelimit 0 threshold 1" >> /var/etc/igmpproxy.conf

	if [ -n "$altnets" ]; then
		local altnet
		for altnet in $altnets; do
			echo -e "\taltnet $altnet" >> /var/etc/igmpproxy.conf
		done
	fi

	if [ -n "$whitelists" ]; then
		local whitelist
		for whitelist in $whitelists; do
			echo -e "\twhitelist $whitelist" >> /var/etc/igmpproxy.conf
		done
	fi
}

service_triggers() {
	procd_add_reload_trigger "igmpproxy"
}

start_service() {
	config_load igmpproxy

	config_foreach igmp_header igmpproxy
	config_foreach igmp_add_phyint phyint

	[ $has_upstream = 1 ] || return

	procd_open_instance
	procd_set_param command $PROG
	[ -n "$OPTIONS" ] && procd_append_param $OPTIONS
	procd_append_param command $CONFIGFILE
	procd_set_param file $CONFIGFILE
	procd_set_param respawn
	procd_close_instance
}
